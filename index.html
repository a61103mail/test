<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全維度戰情室 (雙向驗證版)</title>
    <style>
        :root {
            --bg: #0b0e11;
            --card: #161a1e;
            --text-main: #eaecef;
            --text-sub: #848e9c;
            --green: #0ecb81;
            --green-bg: rgba(14, 203, 129, 0.15);
            --red: #f6465d;
            --red-bg: rgba(246, 70, 93, 0.15);
            --yellow: #fcd535;
            --yellow-bg: rgba(252, 213, 53, 0.1);
            --border: #2b3139;
        }
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            font-size: 13px;
        }
        
        .header {
            border-bottom: 2px solid var(--border);
            padding-bottom: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .symbol-row {
            display: grid;
            grid-template-columns: 160px 1fr 1fr 1fr;
            gap: 10px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .col-info {
            background: #1e2329;
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 1px solid var(--border);
        }
        .sym-name { font-size: 20px; font-weight: 900; color: #fff; }
        .sym-price { font-size: 16px; font-family: 'Roboto Mono'; font-weight: bold; margin-top: 5px; }
        .up { color: var(--green); } .down { color: var(--red); }

        .col-tf {
            padding: 8px;
            border-right: 1px dashed #333;
            display: flex;
            flex-direction: column;
        }
        .col-tf:last-child { border-right: none; }

        .tf-header {
            margin-bottom: 8px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .tf-title-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .tf-title { font-weight: bold; font-size: 14px; color: #fff; }
        
        /* 雙向勝率條 (核心修改) */
        .wr-bar-bg { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; display: flex; }
        .wr-bar-long { height: 100%; background: var(--green); transition: width 0.5s; }
        .wr-bar-short { height: 100%; background: var(--red); transition: width 0.5s; }
        .wr-text { font-size: 10px; display: flex; justify-content: space-between; color: #888; margin-top: 2px; }

        .ind-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            margin-bottom: 8px;
        }
        .ind-item {
            font-size: 11px;
            display: flex; 
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.03); 
            padding: 4px 6px; 
            border-radius: 3px;
        }
        .ind-left { display: flex; flex-direction: column; }
        .ind-right { text-align: right; }
        .ind-name { color: #aaa; font-size: 10px; }
        .ind-val { font-family: 'Roboto Mono'; font-weight: bold; color: #fff; }
        
        .win-dual { font-size: 10px; font-family: 'Roboto Mono'; display: flex; gap: 5px; }
        .w-l { color: var(--green); opacity: 0.5; }
        .w-s { color: var(--red); opacity: 0.5; }
        .active-side { opacity: 1; font-weight: bold; text-decoration: underline; }

        /* 策略區塊 */
        .strat-box {
            margin-top: auto;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid transparent;
        }
        .strat-long { background: var(--green-bg); border-color: var(--green); }
        .strat-short { background: var(--red-bg); border-color: var(--red); }
        
        /* 垃圾行情警告樣式 */
        .strat-chop { 
            background: var(--yellow-bg); 
            border-color: var(--yellow); 
            border-style: dashed;
            color: var(--yellow);
        }
        .strat-wait { background: #2b3139; border-color: #444; color: #888; }

        .strat-title { font-size: 13px; font-weight: bold; margin-bottom: 6px; display: block; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
        .s-long { color: var(--green); } .s-short { color: var(--red); } .s-chop { color: var(--yellow); }

        .strat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 6px 10px;
            font-size: 11px;
            text-align: left;
        }
        .sg-item { display: flex; flex-direction: column; }
        .sg-label { color: var(--text-sub); scale: 0.9; transform-origin: left; }
        .sg-val { font-family: 'Roboto Mono'; font-weight: bold; color: #fff; }
        .blur-text { filter: blur(4px); opacity: 0.5; } /* 隱藏數值用 */

        .loading-bar { text-align: center; color: var(--yellow); padding: 20px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div class="header">
    <div>
        <h1 style="margin:0; font-size:22px;">全維度戰情室 (V14 雙向驗證版)</h1>
        <span style="color:#888; font-size:12px;">
            邏輯修正：多空勝率雙重回測 | 垃圾行情過濾 (雙殺盤識別) | 數據源: 幣安合約
        </span>
    </div>
    <div id="sys-status" style="color:var(--yellow); font-weight:bold;">初始化中...</div>
</div>

<div id="grid-container">
    <div class="loading-bar">
        系統正在執行「雙盲回測」：<br>
        1. 計算順勢勝率<br>
        2. 計算反向勝率<br>
        3. 過濾無效盤整<br>
        請稍候...
    </div>
</div>

<script>
    const SYMBOLS = ['btcusdt', 'ethusdt', 'adausdt', 'solusdt', 'xrpusdt', 'riverusdt', 'nxpcusdt'];
    const TFS = ['15m', '1h', '4h'];
    const LIMIT = 500; 
    
    const TRANS = {
        '15m': '15分鐘 (短線)',
        '1h': '1小時 (波段)',
        '4h': '4小時 (趨勢)',
        'RSI': '相對強弱',
        'EMA': '趨勢均線',
        'MACD': '動能指標',
        'VWAP': '成交均價',
        'BOLL': '布林通道'
    };

    const store = {}; 

    const MathEngine = {
        sma: (d, p) => d.slice(-p).reduce((a,b)=>a+b,0)/p,
        emaArray: (data, period) => {
            let k = 2 / (period + 1);
            let ema = [data[0]];
            for (let i = 1; i < data.length; i++) ema.push(data[i] * k + ema[i-1] * (1 - k));
            return ema;
        },
        rsiArray: (closes) => {
            let rsi = [];
            let gains = 0, losses = 0;
            for(let i=1; i<=14; i++) {
                let diff = closes[i] - closes[i-1];
                if(diff>0) gains+=diff; else losses-=diff;
            }
            let avgGain = gains/14; let avgLoss = losses/14;
            rsi[14] = 100 - (100/(1+avgGain/avgLoss));
            for(let i=15; i<closes.length; i++) {
                let diff = closes[i] - closes[i-1];
                if(diff>0) { avgGain=(avgGain*13+diff)/14; avgLoss=(avgLoss*13)/14; }
                else { avgGain=(avgGain*13)/14; avgLoss=(avgLoss*13-diff)/14; }
                rsi[i] = avgLoss===0 ? 100 : 100 - (100/(1+avgGain/avgLoss));
            }
            return rsi;
        },
        atr: (h, l, c, p=14) => {
            if(h.length < p) return 0;
            let trs = [];
            for(let i=1; i<h.length; i++) trs.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1])));
            return trs.slice(-p).reduce((a,b)=>a+b,0)/p;
        },
        // 核心回測：計算特定方向的勝率
        getWinRate: (signals, closes, type) => {
            let wins = 0, total = 0;
            const lookahead = 5; 
            for(let i=50; i<signals.length-lookahead; i++) {
                if(signals[i]) {
                    total++;
                    const entry = closes[i];
                    const exit = closes[i+lookahead];
                    if(type === 'long' && exit > entry * 1.001) wins++;
                    else if(type === 'short' && exit < entry * 0.999) wins++;
                }
            }
            return total === 0 ? 0 : Math.round((wins/total)*100);
        }
    };

    function initUI() {
        const container = document.getElementById('grid-container');
        container.innerHTML = ''; 

        SYMBOLS.forEach(sym => {
            store[sym] = {}; 
            
            let html = `
            <div class="symbol-row" id="row-${sym}">
                <div class="col-info">
                    <div class="sym-name">${sym.toUpperCase().replace('USDT','')}</div>
                    <div class="sym-price" id="price-${sym}">---.--</div>
                </div>
            `;

            TFS.forEach(tf => {
                store[sym][tf] = {}; 
                html += `
                <div class="col-tf">
                    <div class="tf-header">
                        <div class="tf-title-row">
                            <span class="tf-title">${TRANS[tf]}</span>
                        </div>
                        <div class="wr-bar-bg">
                            <div class="wr-bar-long" id="bar-l-${sym}-${tf}" style="width:50%"></div>
                            <div class="wr-bar-short" id="bar-s-${sym}-${tf}" style="width:50%"></div>
                        </div>
                        <div class="wr-text">
                            <span id="wr-l-${sym}-${tf}">多 --%</span>
                            <span id="wr-s-${sym}-${tf}">空 --%</span>
                        </div>
                    </div>
                    
                    <div class="ind-list" id="list-${sym}-${tf}">
                        <div style="color:#444;">運算中...</div>
                    </div>

                    <div class="strat-box strat-wait" id="strat-${sym}-${tf}">
                        <span class="strat-title" id="act-${sym}-${tf}">初始化</span>
                        <div class="strat-grid">
                            <div class="sg-item"><span class="sg-label">進場 (Entry)</span><span class="sg-val" id="en-${sym}-${tf}">---</span></div>
                            <div class="sg-item"><span class="sg-label">止損 (SL)</span><span class="sg-val" id="sl-${sym}-${tf}">---</span></div>
                            <div class="sg-item"><span class="sg-label">止盈1 (TP1)</span><span class="sg-val" id="tp1-${sym}-${tf}">---</span></div>
                            <div class="sg-item"><span class="sg-label">止盈2 (TP2)</span><span class="sg-val" id="tp2-${sym}-${tf}">---</span></div>
                        </div>
                    </div>
                </div>`;
            });

            html += `</div>`;
            container.insertAdjacentHTML('beforeend', html);
        });
    }

    async function runAnalysis() {
        initUI();
        
        for(const sym of SYMBOLS) {
            try {
                const promises = TFS.map(tf => 
                    fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${sym.toUpperCase()}&interval=${tf}&limit=${LIMIT}`)
                    .then(res => res.json())
                );
                const results = await Promise.all(promises);

                if(results[0].code) { markInvalid(sym); continue; }

                results.forEach((data, i) => {
                    const tf = TFS[i];
                    data.pop(); 
                    processTimeframe(sym, tf, data);
                });
            } catch(e) { console.error(e); markInvalid(sym); }
        }

        document.getElementById('sys-status').textContent = '● 系統運行中 (Websocket)';
        document.getElementById('sys-status').style.color = '#0ecb81';
        connectWSS();
    }

    function processTimeframe(sym, tf, klines) {
        const closes = klines.map(d => parseFloat(d[4]));
        const highs = klines.map(d => parseFloat(d[2]));
        const lows = klines.map(d => parseFloat(d[3]));
        const len = closes.length;
        const last = len - 1;
        const curPrice = closes[last];

        const atr = MathEngine.atr(highs, lows, closes);
        const rsiArr = MathEngine.rsiArray(closes);
        const ema50Arr = MathEngine.emaArray(closes, 50);
        const vwapArr = MathEngine.emaArray(closes, 90); 
        
        let sma20=[], upper=[], lower=[];
        for(let i=0; i<len; i++) {
            if(i<20) { sma20.push(0); upper.push(0); lower.push(0); continue; }
            let slice = closes.slice(i-20, i);
            let avg = slice.reduce((a,b)=>a+b,0)/20;
            let std = Math.sqrt(slice.map(x=>Math.pow(x-avg,2)).reduce((a,b)=>a+b,0)/20);
            sma20.push(avg); upper.push(avg+2*std); lower.push(avg-2*std);
        }

        let ema12 = MathEngine.emaArray(closes, 12);
        let ema26 = MathEngine.emaArray(closes, 26);
        let macdArr = ema12.map((v,i) => v - ema26[i]);

        // 信號生成
        const sigs = {
            rsi_buy: [], rsi_sell: [], ema_buy: [], ema_sell: [],
            macd_buy: [], macd_sell: [], vwap_buy: [], vwap_sell: [],
            bb_buy: [], bb_sell: []
        };

        for(let i=50; i<len; i++) {
            const c = closes[i];
            sigs.rsi_buy[i] = rsiArr[i] < 40; sigs.rsi_sell[i] = rsiArr[i] > 60;
            sigs.ema_buy[i] = c > ema50Arr[i]; sigs.ema_sell[i] = c < ema50Arr[i];
            sigs.macd_buy[i] = macdArr[i] > 0; sigs.macd_sell[i] = macdArr[i] < 0;
            sigs.vwap_buy[i] = c > vwapArr[i]; sigs.vwap_sell[i] = c < vwapArr[i];
            sigs.bb_buy[i] = c > upper[i]; sigs.bb_sell[i] = c < lower[i];
        }

        // 雙向回測
        const calcWR = (buySig, sellSig) => {
            return {
                long: MathEngine.getWinRate(buySig, closes, 'long'),
                short: MathEngine.getWinRate(sellSig, closes, 'short')
            };
        };

        const wrRSI = calcWR(sigs.rsi_buy, sigs.rsi_sell);
        const wrEMA = calcWR(sigs.ema_buy, sigs.ema_sell);
        const wrMACD = calcWR(sigs.macd_buy, sigs.macd_sell);
        const wrVWAP = calcWR(sigs.vwap_buy, sigs.vwap_sell);
        const wrBB = calcWR(sigs.bb_buy, sigs.bb_sell);

        const fVal = (v) => v < 10 ? v.toFixed(4) : v.toFixed(2);
        const getDir = (bull, bear) => bull ? 'long' : bear ? 'short' : 'neu';

        const indData = [
            { id:'RSI', n:'相對強弱', val: rsiArr[last].toFixed(1), dir: getDir(rsiArr[last]>55, rsiArr[last]<45), wr: wrRSI },
            { id:'EMA', n:'趨勢均線', val: fVal(ema50Arr[last]), dir: getDir(curPrice>ema50Arr[last], curPrice<ema50Arr[last]), wr: wrEMA },
            { id:'MACD', n:'動能指標', val: macdArr[last].toFixed(4), dir: getDir(macdArr[last]>0, macdArr[last]<0), wr: wrMACD },
            { id:'VWAP', n:'成交均價', val: fVal(vwapArr[last]), dir: getDir(curPrice>vwapArr[last], curPrice<vwapArr[last]), wr: wrVWAP },
            { id:'BOLL', n:'布林通道', val: curPrice>upper[last]?'上破':curPrice<lower[last]?'下破':'區間', dir: getDir(curPrice>upper[last], curPrice<lower[last]), wr: wrBB }
        ];

        const listEl = document.getElementById(`list-${sym}-${tf}`);
        let listHtml = '';
        
        // 統計變數
        let sumLongWR = 0, sumShortWR = 0, count = 0;
        let activeLongWR = 0, activeShortWR = 0;
        
        indData.forEach(ind => {
            // 計算「潛在」勝率平均 (不管當前方向，我們想知道這個幣種這個時區，多好做還是空好做)
            // 這裡取該指標觸發時的勝率
            const l_wr = ind.wr.long;
            const s_wr = ind.wr.short;
            
            if(l_wr > 0) sumLongWR += l_wr;
            if(s_wr > 0) sumShortWR += s_wr;
            count++;

            const isLong = ind.dir === 'long';
            const isShort = ind.dir === 'short';
            const color = isLong ? 'var(--green)' : isShort ? 'var(--red)' : '#666';
            
            // 累積當前激活方向的勝率 (用於最終決策)
            if(isLong) activeLongWR += l_wr;
            if(isShort) activeShortWR += s_wr;

            const longClass = isLong ? 'w-l active-side' : 'w-l';
            const shortClass = isShort ? 'w-s active-side' : 'w-s';

            listHtml += `
                <div class="ind-item">
                    <div class="ind-left">
                        <span class="ind-name">${ind.n} <span style="font-family:Arial; opacity:0.5">(${ind.id})</span></span>
                        <span class="ind-val" style="color:${color}">${ind.val}</span>
                    </div>
                    <div class="ind-right">
                        <div class="win-dual">
                            <span class="${longClass}">多${l_wr}%</span>
                            <span style="color:#444">|</span>
                            <span class="${shortClass}">空${s_wr}%</span>
                        </div>
                    </div>
                </div>
            `;
        });
        listEl.innerHTML = listHtml;

        const avgLong = Math.round(sumLongWR / count);
        const avgShort = Math.round(sumShortWR / count);
        
        // 更新條形圖
        const total = avgLong + avgShort;
        const longPct = total === 0 ? 50 : (avgLong / total) * 100;
        document.getElementById(`bar-l-${sym}-${tf}`).style.width = `${longPct}%`;
        document.getElementById(`bar-s-${sym}-${tf}`).style.width = `${100-longPct}%`;
        document.getElementById(`wr-l-${sym}-${tf}`).textContent = `多 ${avgLong}%`;
        document.getElementById(`wr-s-${sym}-${tf}`).textContent = `空 ${avgShort}%`;

        // --- 核心邏輯修正：盤整盤過濾 ---
        const stratBox = document.getElementById(`strat-${sym}-${tf}`);
        const actTitle = document.getElementById(`act-${sym}-${tf}`);
        const enEl = document.getElementById(`en-${sym}-${tf}`);
        const slEl = document.getElementById(`sl-${sym}-${tf}`);
        const tp1El = document.getElementById(`tp1-${sym}-${tf}`);
        const tp2El = document.getElementById(`tp2-${sym}-${tf}`);
        const sgVals = stratBox.querySelectorAll('.sg-val');

        // 決策樹
        let decision = 'wait';
        
        // 情況 1: 多方勝率顯著 > 50% 且 > 空方
        if (avgLong >= 53 && avgLong > avgShort) decision = 'long';
        
        // 情況 2: 空方勝率顯著 > 50% 且 > 多方
        else if (avgShort >= 53 && avgShort > avgLong) decision = 'short';
        
        // 情況 3: 雙方勝率都爛 (例如 多42% vs 空38%) -> 垃圾盤
        else if (avgLong < 50 && avgShort < 50) decision = 'chop';
        
        // 情況 4: 雖然勝率高，但沒有明確指標支持 (震盪偏多/空) -> 觀望
        // 這邊簡化處理，相信勝率

        if (decision === 'long') {
            stratBox.className = 'strat-box strat-long';
            actTitle.innerHTML = `<span class="s-long">建議做多 (歷史勝率${avgLong}%)</span>`;
            enEl.textContent = fVal(curPrice);
            slEl.textContent = fVal(curPrice - (atr * 1.5));
            tp1El.textContent = fVal(curPrice + (atr * 1.2));
            tp2El.textContent = fVal(curPrice + (atr * 2.5));
            sgVals.forEach(el => el.classList.remove('blur-text'));
        } 
        else if (decision === 'short') {
            stratBox.className = 'strat-box strat-short';
            actTitle.innerHTML = `<span class="s-short">建議做空 (歷史勝率${avgShort}%)</span>`;
            enEl.textContent = fVal(curPrice);
            slEl.textContent = fVal(curPrice + (atr * 1.5));
            tp1El.textContent = fVal(curPrice - (atr * 1.2));
            tp2El.textContent = fVal(curPrice - (atr * 2.5));
            sgVals.forEach(el => el.classList.remove('blur-text'));
        } 
        else if (decision === 'chop') {
            // 觸發垃圾盤過濾器
            stratBox.className = 'strat-box strat-chop';
            actTitle.innerHTML = `<span class="s-chop">⚠️ 盤整 (雙殺風險)</span>`;
            // 隱藏點位以防手癢
            enEl.textContent = '---'; slEl.textContent = '---'; tp1El.textContent = '---'; tp2El.textContent = '---';
            sgVals.forEach(el => el.classList.add('blur-text'));
        } 
        else {
            stratBox.className = 'strat-box strat-wait';
            actTitle.innerHTML = `<span>觀望 / 方向不明</span>`;
            enEl.textContent = '---'; slEl.textContent = '---'; tp1El.textContent = '---'; tp2El.textContent = '---';
            sgVals.forEach(el => el.classList.remove('blur-text'));
        }
    }

    function markInvalid(sym) {
        document.getElementById(`row-${sym}`).style.opacity = '0.4';
    }

    function connectWSS() {
        const streams = SYMBOLS.map(s => `${s}@ticker`).join('/');
        const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams}`);
        ws.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            const sym = msg.data.s.toLowerCase();
            const price = parseFloat(msg.data.c);
            
            const el = document.getElementById(`price-${sym}`);
            if(el) {
                el.textContent = price;
                el.className = `sym-price ${parseFloat(msg.data.P)>=0?'up':'down'}`;
            }
        };
    }

    runAnalysis();
</script>
</body>
</html>
