<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¨ç¶­åº¦æˆ°æƒ…å®¤ (V70 åš´æ ¼é¢¨æ§ç‰ˆ)</title>
    <style>
        /* V70: åš´æ ¼ä¿ç•™ V68 UIï¼Œå®Œå…¨æœªå‹• */
        :root {
            --bg: #0b0e11; --card: #161a1e; --text-main: #eaecef; --text-sub: #848e9c;
            --green: #0ecb81; --green-bg: rgba(14, 203, 129, 0.15);
            --red: #f6465d; --red-bg: rgba(246, 70, 93, 0.15);
            --yellow: #fcd535; --yellow-bg: rgba(252, 213, 53, 0.1);
            --gold: #ffd700; --gold-bg: rgba(255, 215, 0, 0.25);
            --silver: #e0e0e0; --silver-bg: rgba(224, 224, 224, 0.15);
            --bronze: #ffad5e; --bronze-bg: rgba(255, 173, 94, 0.15);
            --blue: #2979ff; --blue-bg: rgba(41, 121, 255, 0.15);
            --purple: #bf5af2; --purple-bg: rgba(191, 90, 242, 0.2);
            --ai-color: #00bcd4; --ai-bg: rgba(0, 188, 212, 0.1);
            --border: #2b3139; --modal-bg: #1e2329; --header-hover: #20252b;
        }
        body { background-color: var(--bg); color: var(--text-main); font-family: 'Microsoft JhengHei', 'Roboto Mono', sans-serif; margin: 0; padding: 15px; font-size: 13px; }
        
        .header { border-bottom: 2px solid var(--border); padding-bottom: 15px; margin-bottom: 15px; display: flex; flex-direction: column; gap: 10px; }
        .header-top { display: flex; justify-content: space-between; align-items: center; }
        
        .api-input-box { display: flex; gap: 10px; align-items: center; background: #1e2329; padding: 5px 10px; border-radius: 4px; border: 1px solid #333; }
        .api-input { background: transparent; border: none; color: var(--gold); width: 200px; font-family: 'Roboto Mono'; font-size: 12px; outline: none; }
        
        .btn-filter { background: #2b3139; color: #fff; border: 1px solid #444; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 5px; }
        .btc-bar { background: #1e2329; padding: 6px 12px; border-radius: 4px; border-left: 4px solid var(--yellow); font-size: 11px; display: flex; gap: 15px; margin-bottom: 10px; align-items: center; }
        .timer-bar-bg { width: 100px; height: 4px; background: #333; border-radius: 2px; margin-left: 15px; overflow: hidden; }
        .timer-bar-fill { height: 100%; background: var(--yellow); width: 100%; transition: width 1s linear; }
        
        /* å¾½ç«  */
        .tier-badge { font-size: 12px; padding: 3px 8px; border-radius: 4px; font-weight: bold; margin-left: 10px; display: none; }
        .tier-s { background: var(--gold-bg); color: var(--gold); border: 1px solid var(--gold); display: inline-block; box-shadow: 0 0 8px rgba(255, 215, 0, 0.3); animation: pulse 2s infinite; }
        .tier-a { background: var(--silver-bg); color: var(--silver); border: 1px solid var(--silver); display: inline-block; }
        .tier-b { background: var(--bronze-bg); color: var(--bronze); border: 1px solid var(--bronze); display: inline-block; }
        .tier-q { background: var(--purple-bg); color: var(--purple); border: 1px solid var(--purple); display: inline-block; animation: pulse 2s infinite; }
        .tier-z { background: #333; color: #666; border: 1px dashed #555; display: inline-block; }

        /* AI ç‹€æ…‹ */
        .ai-status { font-size: 11px; color: var(--ai-color); margin-left: 10px; font-weight: bold; display: none; }
        .ai-thinking { animation: blink 1s infinite; }
        .ai-error { color: var(--red); animation: none; }
        .ai-box { margin-top: 8px; padding: 8px; background: var(--ai-bg); border: 1px solid var(--ai-color); border-radius: 4px; font-size: 11px; display: none; }
        .ai-head { display: flex; justify-content: space-between; font-weight: bold; color: var(--ai-color); margin-bottom: 4px; border-bottom: 1px dashed var(--ai-color); padding-bottom: 2px; }

        /* æ‰‹å‹•æŒ‰éˆ• */
        .btn-ai-manual { 
            background: linear-gradient(135deg, #00e676, #00a854); 
            color: #000; border: none; padding: 2px 8px; 
            border-radius: 4px; font-weight: bold; font-size: 10px; 
            cursor: pointer; margin-left: 8px; display: none;
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* å¡ç‰‡ä½ˆå±€ */
        .coin-card { background: var(--card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 10px; overflow: hidden; transition: all 0.2s ease; }
        .coin-card.expanded { border-color: #666; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .card-header { padding: 12px 15px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background: #1e2329; border-bottom: 1px solid transparent; }
        .coin-card.expanded .card-header { border-bottom: 1px solid var(--border); background: #252a30; }
        
        .ch-left { display: flex; align-items: center; gap: 10px; }
        .sym-name { font-size: 16px; font-weight: 900; color: #fff; width: 80px; }
        .sym-price { font-family: 'Roboto Mono'; font-weight: bold; font-size: 15px; width: 85px; }
        .up { color: var(--green); } .down { color: var(--red); }
        .ch-right { display: flex; align-items: center; gap: 10px; }
        .risk-tag { font-size: 10px; padding: 2px 5px; border-radius: 3px; background: #333; color: #888; }
        .risk-high { background: var(--red-bg); color: var(--red); font-weight: bold; animation: blink 1s infinite; }
        .signal-badge { font-size: 12px; padding: 3px 8px; border-radius: 4px; font-weight: bold; min-width: 80px; text-align: center; }
        .sb-long { background: var(--green-bg); color: var(--green); border: 1px solid var(--green); }
        .sb-short { background: var(--red-bg); color: var(--red); border: 1px solid var(--red); }
        .sb-chop { background: var(--yellow-bg); color: var(--yellow); border: 1px dashed var(--yellow); }
        .sb-wait { background: #333; color: #888; border: 1px solid #555; }
        .arrow-icon { font-size: 10px; color: #666; transition: transform 0.3s; }
        .coin-card.expanded .arrow-icon { transform: rotate(180deg); }
        
        .card-body { display: none; padding: 10px; background: #111; grid-template-columns: 200px 1fr 1fr 1fr; gap: 10px; }
        .coin-card.expanded .card-body { display: grid; }
        
        .col-info { padding: 10px; border-right: 1px dashed #333; display: flex; flex-direction: column; gap: 8px; }
        .col-tf { padding: 5px; border-right: 1px dashed #333; display: flex; flex-direction: column; }
        .col-tf:last-child { border-right: none; }
        
        .tf-header { margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 3px; display: flex; justify-content: space-between; }
        .tf-title { font-weight: bold; font-size: 13px; color: #fff; }
        .countdown-text { font-family: 'Roboto Mono'; font-size: 10px; color: #aaa; margin-left: 5px; float: right;}

        .wr-bar-bg { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; display: flex; margin-bottom: 2px; }
        .wr-bar-long { height: 100%; background: var(--green); transition: width 0.5s; }
        .wr-bar-short { height: 100%; background: var(--red); transition: width 0.5s; }
        .wr-text { font-size: 10px; display: flex; justify-content: space-between; color: #888; margin-bottom: 5px; }

        .ind-list { display: grid; grid-template-columns: 1fr; gap: 3px; margin-bottom: 8px; }
        .ind-item { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 5px; background: rgba(255,255,255,0.03); border-radius: 3px; }
        .win-dual { font-family: 'Roboto Mono'; font-size: 10px; }
        .active-side { font-weight: bold; text-decoration: underline; opacity: 1 !important; }
        
        /* æˆ°è¡“å…­å®®æ ¼ */
        .strat-box { margin-top: auto; padding: 5px; border-radius: 4px; text-align: center; border: 1px solid transparent; }
        .strat-long { background: var(--green-bg); border-color: var(--green); }
        .strat-short { background: var(--red-bg); border-color: var(--red); }
        .strat-wait { background: #2b3139; border-color: #444; color: #888; }
        .strat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px; text-align: left; margin-top: 5px; }
        .sg-row { display: flex; justify-content: space-between; border-bottom: 1px dashed rgba(255,255,255,0.1); padding-bottom: 2px; }
        .sg-label { color: #888; font-size: 10px; }
        .sg-val { font-family: 'Roboto Mono'; font-weight: bold; color: #fff; }
        .sg-trailing { color: var(--blue); font-weight: bold; } 
        .sg-profit { color: var(--gold); font-weight: bold; }

        .vol-box, .flow-box { padding-top: 5px; border-top: 1px dashed #333; font-size: 11px; }
        .flow-bar-bg { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; display: flex; margin-bottom: 2px; }
        .flow-buy { height: 100%; background: var(--green); } .flow-sell { height: 100%; background: var(--red); }
        .vol-tag { padding: 1px 4px; border-radius: 2px; font-weight: bold; }
        .v-high { background: var(--yellow); color: #000; } .v-norm { background: #444; color: #ccc; } .v-low { background: #222; color: #666; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; display: none; justify-content: center; align-items: center; }
        .modal-content { background: var(--modal-bg); width: 90%; max-width: 600px; max-height: 80vh; border-radius: 8px; border: 1px solid #444; display: flex; flex-direction: column; }
        .modal-body { padding: 15px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; }
        .coin-option { background: #0b0e11; padding: 8px; border-radius: 4px; border: 1px solid #333; cursor: pointer; text-align: center; font-family: 'Roboto Mono'; font-size: 12px; }
        .coin-option.selected { background: var(--green-bg); border-color: var(--green); color: var(--green); font-weight: bold; }
        .search-input { background: #0b0e11; border: 1px solid #444; color: #fff; padding: 8px; width: 90%; margin: 10px 5%; box-sizing: border-box; }
        .loading-text { text-align: center; color: #666; margin-top: 50px; font-size: 16px; }
        
        @media (max-width: 900px) { .card-body { grid-template-columns: 1fr; gap: 0; } .col-info { border-right: none; border-bottom: 1px solid var(--border); padding-bottom: 10px; } .col-tf { border-right: none; border-bottom: 1px dashed #333; padding: 10px 0; } .ind-list { grid-template-columns: 1fr 1fr; gap: 5px; } }
    </style>
</head>
<body>

<div class="modal-overlay" id="filterModal">
    <div class="modal-content">
        <div style="padding:15px; border-bottom:1px solid #333; display:flex; justify-content:space-between;">
            <span style="font-weight:bold;">é¸æ“‡å¹£ç¨®</span>
            <span style="cursor:pointer;" onclick="closeModal()">âœ•</span>
        </div>
        <div style="padding:10px;">
            <input type="text" class="search-input" id="coinSearch" placeholder="æœå°‹..." onkeyup="filterCoins()">
        </div>
        <div class="modal-body" id="coinList">è¼‰å…¥ä¸­...</div>
        <div style="padding:15px; text-align:right; border-top:1px solid #333;">
            <button onclick="applyFilter()" style="background:var(--green); border:none; padding:8px 20px; border-radius:4px; font-weight:bold; cursor:pointer;">ç¢ºèª</button>
        </div>
    </div>
</div>

<div class="header">
    <div class="header-top">
        <div>
            <h1 style="margin:0; font-size:20px;">å…¨ç¶­åº¦æˆ°æƒ…å®¤ (V70 åš´æ ¼é¢¨æ§)</h1>
            <div class="btc-bar" style="margin-top:5px;">
                <span>BTC éŒ¨å®š: <strong id="btc-trend">ç›£æ§ä¸­...</strong></span>
                <span>æ¬Šé‡: <strong id="btc-weight">x1.0</strong></span>
                <div class="timer-bar-bg" title="æ•¸æ“šåˆ·æ–°å€’æ•¸"><div class="timer-bar-fill" id="timer-bar"></div></div>
                <button onclick="testDiscord()" style="margin-left:10px; background:#5865F2; border:1px solid #555; color:#fff; cursor:pointer; font-size:10px; border-radius:4px;">ğŸ’¬ æ¸¬è©¦DC</button>
            </div>
        </div>
        <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-end;">
            <div class="api-input-box">
                <span style="font-size:10px; color:#888;">Gemini API:</span>
                <input type="password" id="gemini-key" class="api-input" placeholder="è²¼ä¸Šä½ çš„ API Key (qvvl...)" onchange="saveKey()">
            </div>
            <button class="btn-filter" onclick="openModal()"><span>â•</span> ç¯©é¸</button>
        </div>
    </div>
</div>

<div id="grid-container">
    <div class="loading-text">æ­£åœ¨æƒæå¸‚å ´æˆäº¤é‡å‰ 10 å...</div>
</div>

<script>
    // ==========================================
    // âš™ï¸ è¨­å®šå€åŸŸ
    // ==========================================
    const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1465999617937248321/oW1PzIAY4KXSbAT8XBk-iK3yO_n8huZtXhgDKM88_pc5dGRs9O74SAouMGP3NuPpDbjl"; 
    // ==========================================

    const TFS = ['15m', '1h', '4h'];
    const LIMIT = 500;
    const TRANS = { '15m': '15m (çŸ­)', '1h': '1H (æ³¢)', '4h': '4H (è¶¨)' };

    let allSymbols = [];
    let activeSymbols = new Set();
    let btcHistory = []; 
    let btcTrendMultiplier = 1.0;
    let wss = null;
    let store = {};
    let fundingRates = {}; 
    let refreshInterval = null; 
    let countdownTimer = null;
    let sTierAlerts = new Map();

    document.getElementById('gemini-key').value = localStorage.getItem('gemini_key') || '';
    function saveKey() { localStorage.setItem('gemini_key', document.getElementById('gemini-key').value); }

    // --- [V70] AI å‘¼å« - å¢åŠ æ‡²ç½°æŒ‡ä»¤ ---
    async function askGemini(symbol, data) {
        const apiKey = localStorage.getItem('gemini_key');
        if (!apiKey) return null;

        const prompt = `
        ä½ æ˜¯ä¸€åæ¥µé€Ÿäº¤æ˜“å“¡ã€‚é‡å° ${symbol} (15mç´šåˆ¥) é€²è¡Œåˆ†æã€‚
        ã€æ•¸æ“šã€‘åƒ¹æ ¼:${data.price}, è¶¨å‹¢:${data.d15}, é‡èƒ½:x${data.vol}, ADX:${data.adx}, å¸ƒæ—:${data.bb}, 1Hèµ°å‹¢:${data.d1h}ã€‚
        
        ã€è©•åˆ†éµå¾‹ã€‘
        1. âš ï¸ **åš´é‡è­¦å‘Š**ï¼šè‹¥é‡èƒ½ (Vol) < 0.8ï¼Œä¿¡å¿ƒåˆ†æ•¸ **ä¸å¾—è¶…é 60**ã€‚
        2. è‹¥é‡èƒ½ < 0.5ï¼Œè¦–ç‚ºæ®­å±ç›¤ï¼Œå»ºè­° WAITï¼Œä¿¡å¿ƒ < 50ã€‚
        3. åªæœ‰ç•¶ è¶¨å‹¢ä¸€è‡´ + é‡èƒ½ > 1.2 + ADX > 25 æ™‚ï¼Œæ‰å…è¨±çµ¦å‡º > 80 çš„é«˜ä¿¡å¿ƒã€‚
        
        ã€ä»»å‹™ã€‘
        1. åˆ¤æ–·çœŸçªç ´é‚„æ˜¯å‡çªç ´ã€‚
        2. çµ¦å‡º 0-100 ä¿¡å¿ƒåˆ†æ•¸ (åš´æ ¼éµå®ˆéµå¾‹)ã€‚
        3. 20å­—å…§ç°¡çŸ­æ“ä½œå»ºè­°ã€‚
        
        è«‹å›å‚³åš´æ ¼çš„ JSON æ ¼å¼:
        { "decision": "çœ‹æ¼²/çœ‹è·Œ/è§€æœ›", "confidence": 60, "comment": "é‡èƒ½ä¸è¶³ï¼Œå°å¿ƒå‡çªç ´" }
        `;

        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            if (!response.ok) {
                console.error("Gemini API Error:", response.status, response.statusText);
                return { decision: "ERROR", confidence: 0, comment: `API éŒ¯èª¤: ${response.status}` };
            }

            const result = await response.json();
            if (!result.candidates || !result.candidates[0].content) {
                return { decision: "ERROR", confidence: 0, comment: "ç„¡æ³•è§£æ AI å›æ‡‰" };
            }

            const text = result.candidates[0].content.parts[0].text;
            const jsonText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            return JSON.parse(jsonText);
        } catch (e) {
            console.error("Gemini Fetch Error:", e);
            return { decision: "ERROR", confidence: 0, comment: "é€£ç·šå¤±æ•—" };
        }
    }

    // æ‰‹å‹•/è‡ªå‹• AI è§¸ç™¼å™¨
    window.triggerManualAI = async function(sym, isAuto = false) {
        const aiStatusEl = document.getElementById(`ai-status-${sym}`);
        const aiBoxEl = document.getElementById(`ai-box-${sym}`);
        const data = store[sym]['data_packet']; 
        
        if (!data) {
            if(!isAuto) alert("æ•¸æ“šå°šæœªæº–å‚™å¥½");
            return;
        }
        
        const apiKey = localStorage.getItem('gemini_key');
        if (!apiKey) {
            if(!isAuto) alert("è«‹å…ˆè¼¸å…¥ API Key");
            return;
        }

        if(aiStatusEl) {
            aiStatusEl.style.display = 'inline';
            aiStatusEl.textContent = 'ğŸ¤– åˆ†æä¸­...';
            aiStatusEl.className = 'ai-status ai-thinking';
        }

        let aiComment = "æœªå•Ÿç”¨ AI";
        let aiConf = 0;
        
        const aiData = {
            price: data.price,
            d15: data.d15, d1h: data.d1h,
            vol: data.vol, adx: data.adx,
            bb: data.bb, k15: data.k15,
            strategy: data.strategy
        };
        
        const aiRes = await askGemini(sym, aiData);
        
        if (aiRes && aiRes.decision !== "ERROR") {
            aiComment = aiRes.comment;
            aiConf = aiRes.confidence;
            
            if(aiStatusEl) {
                aiStatusEl.textContent = `ğŸ¤– AI: ${aiRes.decision} (${aiRes.confidence}%)`;
                aiStatusEl.className = 'ai-status';
            }
            if(aiBoxEl) {
                aiBoxEl.style.display = 'block';
                aiBoxEl.innerHTML = `<div class="ai-head"><span>ğŸ¤– æˆ°è¡“åƒè¬€</span><span>ä¿¡å¿ƒ: ${aiRes.confidence}%</span></div><div>${aiRes.comment}</div>`;
            }
            
            const msg = `
${data.tier === 'S' ? 'ğŸ† **Sç´š**' : (data.tier === 'A' ? 'ğŸ¥ˆ **Aç´š**' : 'ğŸ¥‰ **Bç´š**')} **æ©Ÿæœƒåµæ¸¬** ${data.emoji}
**${sym.toUpperCase().replace('USDT','')}**
ğŸ’° **ç¾åƒ¹**: ${data.price}
ğŸ¯ **TP1**: ${data.tp1} | ğŸš€ **TP2**: ${data.tp2}
ğŸ›¡ï¸ **ç§»å‹•æ­¢æ**: ${data.sl}
ğŸŒŠ **æ½›åœ¨ç²åˆ©**: ${data.pnl}%
**ç­–ç•¥**: ${data.strategy}
(Vol: x${data.vol} | ADX: ${data.adx})

ğŸ¤– **AI åƒè¬€**: ${aiComment} (ä¿¡å¿ƒ: ${aiConf}%)
            `.trim();
            sendDiscordAlert(msg);

        } else {
            if(aiStatusEl) {
                aiStatusEl.textContent = `ğŸ¤– AI éŒ¯èª¤`;
                aiStatusEl.className = 'ai-status ai-error';
            }
        }
    }

    // æ™‚é–“åŒæ­¥ç›£è½å™¨
    setInterval(() => {
        const now = new Date();
        const m = now.getMinutes();
        const s = now.getSeconds();
        if (m % 15 === 0 && s < 5) {
            autoScanAndSend();
        }
    }, 1000);

    let lastAutoTime = 0;
    async function autoScanAndSend() {
        if (Date.now() - lastAutoTime < 60000) return;
        lastAutoTime = Date.now();
        
        console.log("â° Kç·šæ”¶ç›¤ï¼Œé–‹å§‹è‡ªå‹•æƒæ B ç´šä»¥ä¸Š...");
        
        for (const sym of activeSymbols) {
            if (!store[sym] || !store[sym]['data_packet']) continue;
            const data = store[sym]['data_packet'];
            // V70: åªæœ‰ B ç´šæˆ–ä»¥ä¸Šæ‰æœƒè§¸ç™¼ (ä¸” B ç´šç¾åœ¨æ¢ä»¶æ›´åš´æ ¼äº†)
            if (['S', 'A', 'B'].includes(data.tier)) {
                console.log(`ğŸš€ è‡ªå‹•è§¸ç™¼: ${sym} (${data.tier}ç´š)`);
                await triggerManualAI(sym, true); 
                await new Promise(r => setTimeout(r, 2000));
            }
        }
    }

    function sendDiscordAlert(message) {
        if (!DISCORD_WEBHOOK_URL || DISCORD_WEBHOOK_URL.includes("YOUR_DISCORD_WEBHOOK")) {
            console.log("WebHook Missing"); return;
        }
        const payload = { content: message, username: "æˆ°æƒ…å®¤æŒ‡æ®å®˜", avatar_url: "https://cdn-icons-png.flaticon.com/512/4712/4712109.png" };
        const proxyUrl = "https://corsproxy.io/?" + encodeURIComponent(DISCORD_WEBHOOK_URL);
        fetch(proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }).catch(err => console.error(err));
    }

    function testDiscord() {
        sendDiscordAlert("âœ… **æˆ°æƒ…å®¤ V70 é€£ç·šæˆåŠŸ**\næ¨¡å¼ï¼šåš´æ ¼é‡èƒ½é¢¨æ§ + æ™‚é–“åŒæ­¥è‡ªå‹•ç™¼é€ã€‚");
        alert("å·²ç™¼é€æ¸¬è©¦è¨Šæ¯ã€‚");
    }

    async function fetchTop10Coins() {
        try {
            const res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
            const data = await res.json();
            let pairs = data.filter(t => t.symbol.endsWith('USDT') && !t.symbol.includes('USDC'));
            pairs.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            return new Set(pairs.slice(0, 10).map(t => t.symbol.toLowerCase()));
        } catch (e) { return new Set(['btcusdt', 'ethusdt', 'solusdt', 'dogeusdt', 'xrpusdt', 'adausdt', 'bnbusdt']); }
    }

    async function fetchFundingRates() {
        try {
            const res = await fetch('https://fapi.binance.com/fapi/v1/premiumIndex');
            const data = await res.json();
            data.forEach(d => { fundingRates[d.symbol.toLowerCase()] = parseFloat(d.lastFundingRate) * 100; });
        } catch (e) {}
    }

    async function initSystem() {
        activeSymbols = await fetchTop10Coins();
        await fetchExchangeInfo();
        await startSystemLoop(); 
    }

    async function startSystemLoop() {
        await runAnalysisCycle();
        if(refreshInterval) clearInterval(refreshInterval);
        refreshInterval = setInterval(runAnalysisCycle, 60000);
        startCountdown();
    }

    async function runAnalysisCycle() {
        await checkBTCAnchor();
        await fetchFundingRates();
        await applyFilter(false); 
        startCountdown(); 
    }

    function startCountdown() {
        if(countdownTimer) clearInterval(countdownTimer);
        const bar = document.getElementById('timer-bar');
        let width = 100;
        bar.style.width = '100%';
        countdownTimer = setInterval(() => {
            width -= (100/60); 
            if(width < 0) width = 0;
            bar.style.width = `${width}%`;
        }, 1000);
    }

    async function checkBTCAnchor() {
        try {
            const res = await fetch('https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=1h&limit=100');
            const data = await res.json();
            if(Array.isArray(data)) btcHistory = data.map(d=>parseFloat(d[4]));
            const last = parseFloat(data[data.length-1][4]), prev = parseFloat(data[data.length-2][4]);
            const change = (last - prev) / prev;
            const tEl = document.getElementById('btc-trend'), wEl = document.getElementById('btc-weight');
            if (change < -0.005) { btcTrendMultiplier = 0.6; tEl.textContent = "âš ï¸ ä¸‹è·Œ"; tEl.style.color = "#f6465d"; }
            else if (change > 0.005) { btcTrendMultiplier = 1.3; tEl.textContent = "ğŸš€ ä¸Šæ¼²"; tEl.style.color = "#0ecb81"; }
            else { btcTrendMultiplier = 1.0; tEl.textContent = "âš–ï¸ éœ‡ç›ª"; tEl.style.color = "#fcd535"; }
            wEl.textContent = `x${btcTrendMultiplier.toFixed(1)}`;
        } catch(e) {}
    }

    async function fetchExchangeInfo() {
        try {
            const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await res.json();
            allSymbols = data.symbols.filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING').map(s => s.symbol.replace('USDT', '')).sort();
        } catch (e) {}
    }

    function openModal() { renderCoinList(); document.getElementById('filterModal').style.display = 'flex'; }
    function closeModal() { document.getElementById('filterModal').style.display = 'none'; }
    function renderCoinList() {
        const container = document.getElementById('coinList'); container.innerHTML = '';
        allSymbols.forEach(sym => {
            const code = sym.toLowerCase() + 'usdt';
            const div = document.createElement('div');
            div.className = `coin-option ${activeSymbols.has(code) ? 'selected' : ''}`;
            div.textContent = sym; div.dataset.sym = code;
            div.onclick = () => div.classList.toggle('selected');
            container.appendChild(div);
        });
    }
    function filterCoins() {
        const txt = document.getElementById('coinSearch').value.toUpperCase();
        document.querySelectorAll('.coin-option').forEach(opt => opt.style.display = opt.textContent.includes(txt) ? 'block' : 'none');
    }

    async function applyFilter(fromModal = true) {
        if (fromModal) {
            activeSymbols = new Set(Array.from(document.querySelectorAll('.coin-option.selected')).map(el => el.dataset.sym));
            closeModal();
            startSystemLoop();
            return;
        }
        
        const container = document.getElementById('grid-container');
        container.innerHTML = ''; 
        if(wss) wss.close(); store = {}; 
        
        for (const sym of activeSymbols) { 
            store[sym] = {}; 
            await initSymbol(sym); 
            await new Promise(r => setTimeout(r, 50)); 
        } 
        
        connectWSS(Array.from(activeSymbols));
    }

    async function initSymbol(sym) {
        const container = document.getElementById('grid-container');
        if(container.querySelector('.loading-text')) container.innerHTML = '';
        const fr = fundingRates[sym] || 0;
        const frColor = fr > 0.03 ? '#f6465d' : (fr < 0 ? '#0ecb81' : '#888');

        let html = `
        <div class="coin-card" id="card-${sym}">
            <div class="card-header" onclick="toggleCard('${sym}')">
                <div class="ch-left">
                    <span class="sym-name">${sym.toUpperCase().replace('USDT','')}</span>
                    <span class="tier-badge" id="tier-${sym}"></span>
                    <span id="ai-status-${sym}" class="ai-status"></span>
                    <span class="sym-price" id="price-${sym}">--.--</span>
                    <button class="btn-ai-manual" onclick="event.stopPropagation(); triggerManualAI('${sym}')">ğŸ¤– AI</button>
                </div>
                <div class="ch-right"><span class="risk-tag" id="risk-${sym}">é¢¨éšªè©•ä¼°</span><span class="signal-badge sb-wait" id="badge-15m-${sym}">åˆ†æä¸­...</span><span class="arrow-icon">â–¼</span></div>
            </div>
            <div class="card-body">
                <div class="col-info">
                    <div style="font-size:10px; color:#666; cursor:pointer;" onclick="event.stopPropagation(); removeCard('${sym}')">ç§»é™¤å¹£ç¨® âœ•</div>
                    <div class="vol-box"><div style="color:#aaa; display:flex; justify-content:space-between;"><span>é‡èƒ½(1H)</span><span id="vol-ratio-${sym}">x1.0</span></div><span id="vol-status-${sym}" class="vol-tag v-norm">...</span></div>
                    <div class="flow-box"><div style="color:#aaa; margin-bottom:2px;">Taker(1H)</div><div class="flow-bar-bg"><div class="flow-buy" id="flow-b-${sym}" style="width:50%"></div><div class="flow-sell" id="flow-s-${sym}" style="width:50%"></div></div><div style="display:flex; justify-content:space-between; font-size:10px;"><span id="flow-bv-${sym}" style="color:var(--green)">--%</span><span id="flow-sv-${sym}" style="color:var(--red)">--%</span></div></div>
                    <div style="font-size:10px; color:#888; border-top:1px dashed #333; padding-top:5px;">ADX è¶¨å‹¢å¼·åº¦:<br><span id="adx-${sym}" style="color:var(--yellow); font-weight:bold;">...</span></div>
                    <div style="font-size:10px; color:#888; border-top:1px dashed #333; padding-top:5px;">è³‡é‡‘è²»ç‡:<br><span style="color:${frColor}; font-weight:bold;">${fr.toFixed(4)}%</span></div>
                    <div id="ai-box-${sym}" class="ai-box"></div>
                </div>`;

        TFS.forEach(tf => {
            if(!store[sym]) store[sym] = {};
            store[sym][tf] = {}; 
            html += `
            <div class="col-tf">
                <div class="tf-header"><span class="tf-title">${TRANS[tf]}</span><span id="timer-${sym}-${tf}" class="countdown-text">--:--</span></div>
                <div style="margin-bottom:5px;">
                    <div class="wr-bar-bg"><div class="wr-bar-long" id="bar-l-${sym}-${tf}" style="width:50%"></div><div class="wr-bar-short" id="bar-s-${sym}-${tf}" style="width:50%"></div></div>
                    <div class="wr-text"><span id="wr-l-${sym}-${tf}">å¤š--%</span><span id="wr-s-${sym}-${tf}">ç©º--%</span></div>
                </div>
                <div class="ind-list" id="list-${sym}-${tf}"><div style="color:#444;">ä¸‹è¼‰ä¸­...</div></div>
                <div class="strat-box strat-wait" id="strat-${sym}-${tf}">
                    <span class="strat-title" id="act-${sym}-${tf}">è§€æœ›</span>
                    <div class="strat-grid">
                        <div class="sg-row"><div><span class="sg-label">En</span> <span class="sg-val" id="en-${sym}-${tf}">---</span></div><div><span class="sg-label">Kelly</span> <span class="sg-val" id="kelly-${sym}-${tf}">---</span></div></div>
                        <div class="sg-row"><div><span class="sg-label">TP1</span> <span class="sg-val" id="tp1-${sym}-${tf}">---</span></div><div><span class="sg-label">TP2</span> <span class="sg-val" id="tp2-${sym}-${tf}">---</span></div></div>
                        <div class="sg-row"><div><span class="sg-label">Trail SL</span> <span class="sg-val sg-trailing" id="sl-${sym}-${tf}">---</span></div><div><span class="sg-label">PnL</span> <span class="sg-val sg-profit" id="pnl-${sym}-${tf}">---</span></div></div>
                    </div>
                </div>
            </div>`;
        });
        html += `</div></div>`; 
        container.insertAdjacentHTML('beforeend', html);

        try {
            const promises = TFS.map(tf => fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${sym.toUpperCase()}&interval=${tf}&limit=${LIMIT}`).then(r=>r.json()));
            const results = await Promise.all(promises);
            if(!Array.isArray(results[0]) || results[0].code) { document.getElementById(`badge-15m-${sym}`).textContent = "ç„¡æ•¸æ“š"; return; }
            
            const closes = results[1].map(d=>parseFloat(d[4]));
            const lastClose = closes[closes.length - 1];
            store[sym]['price'] = lastClose;
            const beta = MathEngine.correlation(closes, btcHistory);
            const isHighCorr = beta > 0.7;

            results.forEach((data, i) => {
                const tf = TFS[i]; 
                updateCountdown(sym, tf);
                processTimeframe(sym, tf, data, isHighCorr);
                if(tf === '1h') { calculateFlow(sym, data); calculateVolume(sym, data); }
            });
        } catch(e) { console.error("Init Error", e); }
    }

    function updateCountdown(sym, tf) {
        const el = document.getElementById(`timer-${sym}-${tf}`);
        if(!el) return;
        const now = Date.now();
        let intervalMs = 0;
        if(tf === '15m') intervalMs = 15 * 60 * 1000;
        else if(tf === '1h') intervalMs = 60 * 60 * 1000;
        else intervalMs = 4 * 60 * 60 * 1000;
        const nextClose = Math.ceil(now / intervalMs) * intervalMs;
        const diff = nextClose - now;
        const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const s = Math.floor((diff % (1000 * 60)) / 1000);
        el.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        if(m < 3) el.style.color = '#f6465d'; else el.style.color = '#aaa';
    }

    const MathEngine = {
        sma: (d, p) => d.slice(-p).reduce((a,b)=>a+b,0)/p,
        emaArray: (d, p) => { let k=2/(p+1), ema=[d[0]]; for(let i=1;i<d.length;i++) ema.push(d[i]*k+ema[i-1]*(1-k)); return ema; },
        rsiArray: (c) => { 
            let rsi=[], g=0, l=0; 
            if(c.length < 15) return Array(c.length).fill(50);
            for(let i=1;i<=14;i++){ let d=c[i]-c[i-1]; d>0?g+=d:l-=d; }
            let ag=g/14, al=l/14; rsi[14]=100-(100/(1+ag/al));
            for(let i=15;i<c.length;i++){ let d=c[i]-c[i-1]; d>0?ag=(ag*13+d)/14:al=(al*13-d)/14; rsi[i]=al===0?100:100-(100/(1+ag/al)); }
            return rsi;
        },
        atrArray: (h, l, c, p=14) => {
            let trs = [h[0]-l[0]];
            for(let i=1; i<h.length; i++) trs.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1])));
            let atr = [trs[0]];
            for(let i=1; i<trs.length; i++) if(i < p) atr.push((atr[i-1]*i + trs[i])/(i+1)); else atr.push((atr[i-1]*(p-1) + trs[i])/p);
            return atr;
        },
        adx: (h, l, c, p=14) => {
            let plusDM=[], minusDM=[], tr=[];
            for(let i=1;i<h.length;i++){
                tr.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1])));
                let up=h[i]-h[i-1], down=l[i-1]-l[i];
                plusDM.push((up>down && up>0)?up:0); minusDM.push((down>up && down>0)?down:0);
            }
            const smooth = (arr, len) => {
                let res=[], sum=0;
                for(let i=0;i<arr.length;i++){ sum+=arr[i]; if(i>=len) sum-=arr[i-len]; res.push(i<len?sum/(i+1):sum/len); }
                return res;
            };
            let trS=smooth(tr,p), pDMS=smooth(plusDM,p), mDMS=smooth(minusDM,p);
            let dx=[];
            for(let i=0;i<trS.length;i++){
                let diP = (pDMS[i]/trS[i])*100, diM = (mDMS[i]/trS[i])*100;
                let sum = diP+diM, diff = Math.abs(diP-diM);
                dx.push(sum===0?0:(diff/sum)*100);
            }
            return smooth(dx, p);
        },
        bollinger: (c, p=20, mult=2) => {
            const sma = c.slice(-p).reduce((a,b)=>a+b,0)/p;
            const std = Math.sqrt(c.slice(-p).map(x=>Math.pow(x-sma,2)).reduce((a,b)=>a+b)/p);
            return { upper: sma + mult*std, lower: sma - mult*std, mid: sma, width: sma===0?0:(mult*std*2)/sma };
        },
        getRealisticWinRate: (signals, closes, highs, lows, atrs, direction) => { 
            let wins=0, trades=0;
            if(signals.length < 50) return 50;
            for(let i=50; i<signals.length-24; i++){ 
                if(!signals[i]) continue;
                const entry = closes[i], curATR = atrs[i];
                const slDist = curATR * 1.5, tpDist = curATR * 2.0;
                let sl = direction==='long' ? entry - slDist : entry + slDist;
                let tp = direction==='long' ? entry + tpDist : entry - tpDist;
                let outcome = 'timeout';
                for(let k=1; k<=24; k++){
                    let h = highs[i+k], l = lows[i+k];
                    if(direction==='long'){ if(l <= sl) { outcome='loss'; break; } if(h >= tp) { outcome='win'; break; } } 
                    else { if(h >= sl) { outcome='loss'; break; } if(l <= tp) { outcome='win'; break; } }
                }
                if(outcome==='win') wins++; if(outcome!=='timeout') trades++;
            } 
            return trades<5 ? 50 : Math.round((wins/trades)*100); 
        },
        correlation: (a, b, len=24) => {
            if(!b || b.length < len || a.length < len) return 1;
            const A = a.slice(-len), B = b.slice(-len);
            const avgA = A.reduce((x,y)=>x+y,0)/len, avgB = B.reduce((x,y)=>x+y,0)/len;
            let num=0, denA=0, denB=0;
            for(let i=0;i<len;i++) { let da=A[i]-avgA, db=B[i]-avgB; num+=da*db; denA+=da*da; denB+=db*db; }
            return denA===0||denB===0 ? 0 : num/Math.sqrt(denA*denB);
        },
        calcSmartScore: (metrics) => {
            let total=0, weight=0;
            for(let m of metrics) { if(m[0] > 0) { total += m[0]*m[1]; weight += m[1]; } }
            return weight===0 ? 50 : total/weight;
        },
        kelly: (winRate, riskReward) => {
            const w = winRate / 100;
            const q = 1 - w;
            return (w * riskReward - q) / riskReward;
        }
    };

    function processTimeframe(sym, tf, klines, isHighCorr) {
        try {
            const c = klines.map(d=>parseFloat(d[4])), h=klines.map(d=>parseFloat(d[2])), l=klines.map(d=>parseFloat(d[3]));
            const last=c.length-1, cur=c[last];
            
            if(c.length < 50) { 
                document.getElementById(`list-${sym}-${tf}`).innerHTML = '<div style="color:#666;">æ•¸æ“šä¸è¶³</div>';
                return;
            }

            const atrs = MathEngine.atrArray(h,l,c);
            const curATR = atrs[atrs.length-1];
            const rsi = MathEngine.rsiArray(c);
            const adx = MathEngine.adx(h,l,c);
            const curAdx = adx.length > 0 ? adx[adx.length-1] : 0; 

            const bb = MathEngine.bollinger(c);
            let bbState = 'normal';
            if (bb.width < 0.02) bbState = 'squeeze'; 

            if(tf === '1h') {
                if(!store[sym]) store[sym] = {};
                store[sym]['adx_val'] = curAdx;
                store[sym]['bb_state'] = bbState; 
                const adxEl = document.getElementById(`adx-${sym}`);
                if(adxEl) {
                    adxEl.textContent = curAdx.toFixed(1);
                    adxEl.style.color = curAdx > 25 ? '#f6465d' : '#848e9c'; 
                }
            }

            const ema = MathEngine.emaArray(c, 50);
            const bias = (cur - ema[last]) / ema[last] * 100;
            const vwapArr = MathEngine.emaArray(c, 90); 
            
            let ema12 = MathEngine.emaArray(c, 12);
            let ema26 = MathEngine.emaArray(c, 26);
            let macdArr = ema12.map((v,i) => v - ema26[i]);

            const vwapVal = MathEngine.sma(c, 90);
            const risk = Math.min(100, Math.round((Math.abs(cur-vwapVal)/vwapVal * 500) + ((h[last]-l[last])/curATR * 15)));
            if(tf==='15m') { 
                const rEl = document.getElementById(`risk-${sym}`); 
                if(rEl) { rEl.textContent = `æ’é‡é¢¨éšª ${risk}%`; rEl.className = `risk-tag ${risk>80?'risk-high':''}`; }
            }
            
            if(tf==='1h') {
                const v = klines.map(d=>parseFloat(d[5]));
                let maxV=0, wallP=0; 
                for(let i=last-50;i<=last;i++){ if(v[i]>maxV){ maxV=v[i]; wallP=c[i]; } } 
            }

            const sigs={ r_b:[], r_s:[], e_b:[], e_s:[], m_b:[], m_s:[], v_b:[], v_s:[], b_b:[], b_s:[] };
            for(let i=50; i<=last; i++) {
                sigs.r_b[i]=rsi[i]<40; sigs.r_s[i]=rsi[i]>60;
                sigs.e_b[i]=c[i]>ema[i]; sigs.e_s[i]=c[i]<ema[i];
                sigs.m_b[i]=macdArr[i]>0; sigs.m_s[i]=macdArr[i]<0;
                sigs.v_b[i]=c[i]>vwapArr[i]; sigs.v_s[i]=c[i]<vwapArr[i];
                sigs.b_b[i]=c[i]>bb.upper; sigs.b_s[i]=c[i]<bb.lower;
            }
            
            const wrR = { l: MathEngine.getRealisticWinRate(sigs.r_b,c,h,l,atrs,'long'), s: MathEngine.getRealisticWinRate(sigs.r_s,c,h,l,atrs,'short') };
            const wrE = { l: MathEngine.getRealisticWinRate(sigs.e_b,c,h,l,atrs,'long'), s: MathEngine.getRealisticWinRate(sigs.e_s,c,h,l,atrs,'short') };
            const wrM = { l: MathEngine.getRealisticWinRate(sigs.m_b,c,h,l,atrs,'long'), s: MathEngine.getRealisticWinRate(sigs.m_s,c,h,l,atrs,'short') };
            const wrV = { l: MathEngine.getRealisticWinRate(sigs.v_b,c,h,l,atrs,'long'), s: MathEngine.getRealisticWinRate(sigs.v_s,c,h,l,atrs,'short') };
            const wrB = { l: MathEngine.getRealisticWinRate(sigs.b_b,c,h,l,atrs,'long'), s: MathEngine.getRealisticWinRate(sigs.b_s,c,h,l,atrs,'short') };

            const listEl = document.getElementById(`list-${sym}-${tf}`);
            let lW=0, sW=0, cnt=0;
            const addInd = (n,v,d,w) => {
                const lc=d=='l'?'active-side':'w-l', sc=d=='s'?'active-side':'w-s', col=d=='l'?'var(--green)':d=='s'?'var(--red)':'#666';
                if(w.l>0) lW+=w.l; if(w.s>0) sW+=w.s; cnt++;
                return `<div class="ind-item"><div style="color:#aaa;">${n} <span style="color:${col};font-weight:bold;">${v}</span></div><div class="win-dual"><span class="${lc}">å¤š${w.l}%</span>|<span class="${sc}">ç©º${w.s}%</span></div></div>`;
            };
            
            listEl.innerHTML = 
                addInd('RSI', rsi[last].toFixed(1), rsi[last]>55?'l':rsi[last]<45?'s':'n', wrR) +
                addInd('EMA', cur>ema[last]?'ä¸Š':'ä¸‹', cur>ema[last]?'l':'s', wrE) +
                addInd('MACD', macdArr[last].toFixed(2), macdArr[last]>0?'l':'s', wrM) +
                addInd('VWAP', cur>vwapArr[last]?'ä¸Š':'ä¸‹', cur>vwapArr[last]?'l':'s', wrV) +
                addInd('BOLL', cur>bb.upper?'ç ´':cur<bb.lower?'ç ´':'å€', cur>bb.upper?'l':cur<bb.lower?'s':'n', wrB);

            let wTrend = curAdx > 25 ? 2.0 : 0.5;
            let wOsc = curAdx > 25 ? 0.5 : 2.0;

            const metricsL = [[wrR.l, wOsc], [wrE.l, wTrend], [wrM.l, wTrend], [wrV.l, 1], [wrB.l, wOsc]];
            const metricsS = [[wrR.s, wOsc], [wrE.s, wTrend], [wrM.s, wTrend], [wrV.s, 1], [wrB.s, wOsc]];
            
            let avgL = MathEngine.calcSmartScore(metricsL);
            let avgS = MathEngine.calcSmartScore(metricsS);

            if(isHighCorr && btcTrendMultiplier !== 1.0) {
                if(btcTrendMultiplier < 1.0) avgL *= 0.8;
                if(btcTrendMultiplier > 1.0) avgS *= 0.8;
            }

            document.getElementById(`bar-l-${sym}-${tf}`).style.width = `${Math.min(100, avgL)}%`;
            document.getElementById(`bar-s-${sym}-${tf}`).style.width = `${Math.min(100, avgS)}%`;
            document.getElementById(`wr-l-${sym}-${tf}`).textContent = `å¤š${Math.round(avgL)}%`;
            document.getElementById(`wr-s-${sym}-${tf}`).textContent = `ç©º${Math.round(avgS)}%`;

            const box = document.getElementById(`strat-${sym}-${tf}`), title = document.getElementById(`act-${sym}-${tf}`), f = v => v<10?v.toFixed(4):v.toFixed(2);
            
            const slDist = curATR * 1.5; 
            const tpDist = curATR * 3.0; 

            const slL = cur - slDist; 
            const slS = cur + slDist; 
            
            const tpL1 = cur + curATR * 1.0; const tpL2 = cur + curATR * 3.0;
            const tpS1 = cur - curATR * 1.0; const tpS2 = cur - curATR * 3.0;

            const RR = 3.0 / 1.5; 
            const kellyL = MathEngine.kelly(avgL, RR);
            const kellyS = MathEngine.kelly(avgS, RR);

            let dec = 'wait';
            if(kellyL > 0 && avgL > 50 && avgL > avgS) dec = 'long';
            else if(kellyS > 0 && avgS > 50 && avgS > avgL) dec = 'short';

            let potProfit = 0;
            if(dec === 'long') potProfit = ((tpL2 - cur) / cur) * 100;
            else if(dec === 'short') potProfit = ((cur - tpS2) / cur) * 100;

            if(!store[sym]) store[sym] = {};
            store[sym][tf] = { 
                decision: dec, 
                kelly: Math.round(Math.max(kellyL, kellyS) * 100),
                setup: { long: { sl: slL, tp1: tpL1, tp2: tpL2 }, short: { sl: slS, tp1: tpS1, tp2: tpS2 } } 
            };

            if(tf === '15m') {
                const badge = document.getElementById(`badge-15m-${sym}`);
                if(dec==='long') { badge.className = 'signal-badge sb-long'; badge.textContent = `åšå¤š (K:${(kellyL*100).toFixed(0)}%)`; } 
                else if(dec==='short') { badge.className = 'signal-badge sb-short'; badge.textContent = `åšç©º (K:${(kellyS*100).toFixed(0)}%)`; } 
                else { badge.className='signal-badge sb-wait'; badge.textContent='è§€æœ›'; }
            }

            const vals = box.querySelectorAll('.sg-val');
            
            document.getElementById(`en-${sym}-${tf}`).textContent = f(cur);
            document.getElementById(`kelly-${sym}-${tf}`).textContent = (dec !== 'wait') ? (Math.max(kellyL, kellyS)*100).toFixed(1)+'%' : '---';
            
            if (dec === 'long') {
                box.className = 'strat-box strat-long';
                title.innerHTML = `<span>å»ºè­°åšå¤š</span>`;
                document.getElementById(`tp1-${sym}-${tf}`).textContent = f(tpL1);
                document.getElementById(`tp2-${sym}-${tf}`).textContent = f(tpL2);
                document.getElementById(`sl-${sym}-${tf}`).textContent = f(slL);
                document.getElementById(`pnl-${sym}-${tf}`).textContent = `+${potProfit.toFixed(2)}%`;
                vals.forEach(e=>e.classList.remove('blur-text'));
            } else if (dec === 'short') {
                box.className = 'strat-box strat-short';
                title.innerHTML = `<span>å»ºè­°åšç©º</span>`;
                document.getElementById(`tp1-${sym}-${tf}`).textContent = f(tpS1);
                document.getElementById(`tp2-${sym}-${tf}`).textContent = f(tpS2);
                document.getElementById(`sl-${sym}-${tf}`).textContent = f(slS);
                document.getElementById(`pnl-${sym}-${tf}`).textContent = `+${potProfit.toFixed(2)}%`;
                vals.forEach(e=>e.classList.remove('blur-text'));
            } else {
                box.className = 'strat-box strat-wait';
                title.innerHTML = '<span>è§€æœ›</span>';
                document.getElementById(`tp1-${sym}-${tf}`).textContent = f(tpL1);
                document.getElementById(`tp2-${sym}-${tf}`).textContent = f(tpL2);
                document.getElementById(`sl-${sym}-${tf}`).textContent = f(slL);
                document.getElementById(`pnl-${sym}-${tf}`).textContent = '---';
                vals.forEach(e=>e.classList.add('blur-text'));
            }

            // --- [V70] åš´æ ¼åˆ†ç´šé‚è¼¯ ---
            let tier = '';
            const vol = Math.abs(store[sym]['vol_ratio'] || 0);
            const adx = curAdx;
            const trend1h = store[sym]['1h'].decision || 'wait';

            // åªæœ‰ç•¶ 15m èˆ‡ 1H æ–¹å‘ä¸€è‡´æ‰è€ƒæ…®åˆ†ç´š
            if (dec !== 'wait' && dec === trend1h) {
                if (vol > 1.2 && adx > 25) {
                    tier = 'S'; // é»ƒé‡‘æ©Ÿæœƒï¼šé‡èƒ½å……è¶³ + è¶¨å‹¢å¼·
                } else if (vol > 0.8) {
                    tier = 'A'; // æ¨™æº–æ©Ÿæœƒï¼šé‡èƒ½åŠæ ¼
                } else {
                    tier = 'B'; // å¼±å‹¢æ©Ÿæœƒï¼šé‡èƒ½ä¸è¶³ (å¦‚ x0.2)
                }
            } else if (dec !== 'wait') {
                tier = 'B'; // æ–¹å‘ä¸ä¸€è‡´ä½†æœ‰çŸ­ç·šè¨Šè™Ÿ
            }

            store[sym]['data_packet'] = {
                price: cur,
                d15: dec,
                d1h: trend1h,
                vol: vol.toFixed(2),
                adx: adx.toFixed(1),
                bb: bbState,
                k15: store[sym]['15m'].kelly,
                strategy: dec === 'long' ? 'å»ºè­°åšå¤š' : (dec === 'short' ? 'å»ºè­°åšç©º' : 'è§€æœ›'),
                tier: tier,
                emoji: dec === 'long' ? 'ğŸ“ˆ' : 'ğŸ“‰',
                sl: dec === 'long' ? slL.toFixed(4) : slS.toFixed(4),
                tp1: dec === 'long' ? tpL1.toFixed(4) : tpS1.toFixed(4),
                tp2: dec === 'long' ? tpL2.toFixed(4) : tpS2.toFixed(4),
                pnl: potProfit.toFixed(2)
            };

            // æ›´æ–° UI å¾½ç« 
            const tierBadge = document.getElementById(`tier-${sym}`);
            const aiBtn = document.querySelector(`#card-${sym} .btn-ai-manual`);
            
            if (tier) {
                tierBadge.style.display = 'inline-block';
                tierBadge.textContent = `${tier} ç´š`;
                tierBadge.className = `tier-badge tier-${tier.toLowerCase()}`;
                if(aiBtn) aiBtn.style.display = 'inline-block';
            } else {
                tierBadge.style.display = 'none';
                if(aiBtn) aiBtn.style.display = 'none';
            }

        } catch(e) { console.error(`Error in processTimeframe for ${sym} ${tf}`, e); }
    }

    function calculateVolume(sym, klines) { 
        const len=klines.length, cur=parseFloat(klines[len-1][5]);
        let sum=0; for(let i=len-21;i<len-1;i++) sum+=parseFloat(klines[i][5]);
        const r=cur/(sum/20);
        if(!store[sym]) store[sym] = {};
        store[sym]['vol_ratio'] = r;
        const el=document.getElementById(`vol-status-${sym}`);
        document.getElementById(`vol-ratio-${sym}`).textContent = `x${r.toFixed(1)}`;
        if(r>=2){el.textContent="ğŸ”¥ çˆ†é‡";el.className="vol-tag v-high";} else if(r>=1.2){el.textContent="ğŸ“ˆ æ”¾é‡";el.className="vol-tag v-norm";} else if(r<=0.6){el.textContent="ğŸ’¤ ç¸®é‡";el.className="vol-tag v-low";} else{el.textContent="âš–ï¸ æ­£å¸¸";el.className="vol-tag v-norm";}
    }
    function calculateFlow(sym, klines) {
        const rec=klines.slice(-24); let t=0,b=0; rec.forEach(k=>{t+=parseFloat(k[5]);b+=parseFloat(k[9]);});
        const bp=(b/t)*100; document.getElementById(`flow-b-${sym}`).style.width=`${bp}%`; document.getElementById(`flow-s-${sym}`).style.width=`${100-bp}%`;
        document.getElementById(`flow-bv-${sym}`).textContent=`è²·${bp.toFixed(0)}%`; document.getElementById(`flow-sv-${sym}`).textContent=`è³£${(100-bp).toFixed(0)}%`;
    }

    window.toggleCard = function(sym) { document.getElementById(`card-${sym}`).classList.toggle('expanded'); };
    function removeCard(sym) { activeSymbols.delete(sym); document.getElementById(`card-${sym}`).remove(); }
    function connectWSS(symbols) {
        wss = new WebSocket(`wss://fstream.binance.com/stream?streams=${symbols.map(s => `${s}@ticker`).join('/')}`);
        wss.onmessage = (e) => {
            const m = JSON.parse(e.data).data; const el = document.getElementById(`price-${m.s.toLowerCase()}`);
            if(el) { el.textContent = parseFloat(m.c); el.className = `sym-price ${parseFloat(m.P)>=0?'up':'down'}`; }
        };
    }

    initSystem();
</script>
</body>
</html>
